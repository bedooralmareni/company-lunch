# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ApA8m85fHtKKoYOTO53LC2Yo_8i1NXZb
"""

# check_constraints & Objective function
def setList(x,y,z,p):
    '''
        f=10*X+15*Y+20*Z
        4X+2Y<=400
        2X+3Y+3Z<=300
        X+2Y+3Z<=200
        X+Y+4Z<= 900
        X,Y,Z>=0
    '''
    list=[ ]
    for i in range(0,len(x)):
        for j in range(0,len(y)):
            for l in range(0,len(z)):
                if x[i]>=0 and y[j]>=0 and z[l]>=0:
                    if 4*x[i]+2*y[j]<=400 and 4*x[i]+2*y[j]+3*z[l]<=300 and x[i]+2*y[j]+3*z[l]<=200 and 2*x[i]+y[j]+4*z[l]<=900:
                        P=10*x[i]+15*y[j]+20*z[l]
                        list.append([x[i], y[j], z[l], P])
    return list
# Generate initial solution
def get_InitialSolution(list, setOfSolu):
    for i in range(0,len(setOfSolu)):
        if i == 0:
            optimalSolu = setOfSolu[0][3]
        else:
            optimalSolu = max(optimalSolu, setOfSolu[i][3])

        for i in range(0,len(setOfSolu)):
            if setOfSolu[i][3] == optimalSolu:
                initial_solution = setOfSolu[i]

        for i in range(0,len(list)):
            if list[i][3] == optimalSolu :
               index = i
    return initial_solution, index
#BasicLocalSearch
def BLS(list, index, initsolution):
    initial_solution=initsolution
    list1=[]
    list2=[]
    repeat=20
    optima =0
    # Genertae neighbour
    for i in range(repeat):
        neighborhood1 = list[index + i]
        list1.append(neighborhood1)

        neighborhood2 = list[index - i]
        list2.append(neighborhood2)
    #look for improov   
    for i in range(len(list1)):
        maax = max(initial_solution[3], list1[i][3], list2[i][3])
        if (maax > optima):
            optima = maax
        else:
            optima = optima
    #set improov
    for i in range(len(list)):
        if (list[i][3] == optima):
            initialsolution = list[i]
            index =i
    return index, initialsolution
#check_neighborhood
def neighborhood(index, solution, prvsolution):
    '''
        Takes a  solution 
        returns a new neighbor solution
    '''
    if solution == prvsolution:
        return solution
    else:
        prvsolution = solution
        index, solution = BLS(list, index, solution)
        return neighborhood(index, solution, prvsolution)
x= [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
y= [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
z= [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
list=setList(x,y,z,0)  
x= [4,2,1,1]
y= [2,3,2,1]
z= [0,3,3,4]
firstSolution, index1 = get_InitialSolution(list,setList(x, y, z, 0))
index2, solution = BLS(list, index1, firstSolution)
optimal = neighborhood(index2, solution, firstSolution)
print("Best found of number of chicken sandwich,light chicken sandwich,vegetarian sandwich in order {} \nThe best benefit the company can get: {}".format(optimal[0:3],optimal[3]))